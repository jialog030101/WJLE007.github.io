<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Xv6 on JiaLog</title>
    <link>https://jialog.top/tags/xv6/</link>
    <description>Recent content in Xv6 on JiaLog</description>
    <image>
      <title>JiaLog</title>
      <url>https://jialog.top/images/papermod-cover.png</url>
      <link>https://jialog.top/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.144.2</generator>
    <language>en</language>
    <copyright>JiaLog 豫ICP备2024077894号-1 苏公网安备32031202000962号 32031202000962</copyright>
    <lastBuildDate>Tue, 25 Feb 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jialog.top/tags/xv6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lab1 Xv6 &amp;&amp; system calls</title>
      <link>https://jialog.top/posts/os/lab1-xv6--system-calls/</link>
      <pubDate>Tue, 25 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jialog.top/posts/os/lab1-xv6--system-calls/</guid>
      <description>&lt;h2 id=&#34;using-gdb&#34;&gt;Using gdb&lt;/h2&gt;
&lt;p&gt;平时我们用的调试工具其实都是图形化后的gdb，使用起来非常的方便，但是熟悉原生的gdb会使我们的效率进一步提升。我认为学习好用gdb调试是一项非常重要的技能。&lt;/p&gt;
&lt;h3 id=&#34;编译并启动&#34;&gt;编译并启动&lt;/h3&gt;
&lt;p&gt;==make qemu-gdb==&lt;/p&gt;
&lt;p&gt;使用上述命令&lt;strong&gt;编译项目&lt;/strong&gt;并且直接以&lt;strong&gt;调试&lt;/strong&gt;模式启动。但是这个项目启动的其实是在本地的一个远程gdb，通过另一个窗口进行调试。
&lt;img alt=&#34;PixPin_2025-02-25_13-54-10.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_13-54-10.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面有几个关于系统调用的小问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Looking at the backtrace output, which function called syscall?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;PixPin_2025-02-25_16-13-11.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-13-11.png&#34;&gt;
&lt;img alt=&#34;PixPin_2025-02-25_16-19-46.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-19-46.png&#34;&gt;
显然是usertrap（）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What is the value of p-&amp;gt;trapframe-&amp;gt;a7 and what does that value represent? (Hint: look user/initcode.S, the first user program xv6 starts.)&lt;/strong&gt;
&lt;img alt=&#34;PixPin_2025-02-25_16-26-31.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-26-31.png&#34;&gt;
通过提示找到trapframe的地址，在kernel/proc.h中找到a7寄存器对应的偏移地址。
&lt;img alt=&#34;PixPin_2025-02-25_16-28-03.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-28-03.png&#34;&gt;
把168换算成16进制
&lt;img alt=&#34;PixPin_2025-02-25_16-29-13.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-29-13.png&#34;&gt;
尝试着打印&lt;strong&gt;0x87f560a8&lt;/strong&gt;
&lt;img alt=&#34;PixPin_2025-02-25_16-30-11.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-30-11.png&#34;&gt;
这个就是寄存器a7的值。其代表的具体含义通过所给的提示到对应文件中查找之后也是十分的明了。
&lt;img alt=&#34;PixPin_2025-02-25_16-32-21.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-32-21.png&#34;&gt;
应该就是系统的调用号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What was the previous mode that the CPU was in?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;PixPin_2025-02-25_16-43-14.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-43-14.png&#34;&gt;
spp位表示其在什么状态。 通过图示得出，spp在二进制的第8bit.
&lt;img alt=&#34;PixPin_2025-02-25_17-10-18.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_17-10-18.png&#34;&gt;
由图可知8bit是0，所以之前是用户状态 。
&lt;img alt=&#34;PixPin_2025-02-25_17-26-23.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_17-26-23.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;PixPin_2025-02-25_17-26-05.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_17-26-05.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;system-call-tracing&#34;&gt;System call tracing&lt;/h2&gt;
&lt;h2 id=&#34;attack-xv6&#34;&gt;Attack xv6&lt;/h2&gt;
&lt;p&gt;这个task主要是利用xv6故意留下的bug然后获取到销毁内存但是保留了脏页的数据。然后通过一些比较hack的手段把字段给找出来。&lt;/p&gt;
&lt;h3 id=&#34;page组成&#34;&gt;page组成&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;PixPin_2025-02-28_20-58-24.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-28_20-58-24.png&#34;&gt;
上图是一个简化的逻辑页表，下一个实验也会用到，这里理顺一下逻辑有利于分析代码的组成。
&lt;img alt=&#34;PixPin_2025-02-28_21-01-20.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-28_21-01-20.png&#34;&gt;
上图是地址转化的细节。
页表项（PTE）包含标志位，告诉硬件应该如何使用这些虚拟地址。&lt;img alt=&#34;PixPin_2025-03-02_10-35-10.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-02_10-35-10.png&#34;&gt;
这些相关位的定义都在(kernel/riscv.h)中&lt;/p&gt;</description>
    </item>
    <item>
      <title>虚拟化--进程管理API：fork, execve, exit</title>
      <link>https://jialog.top/posts/os/%E8%99%9A%E6%8B%9F%E5%8C%96--%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86apifork-execve-exit/</link>
      <pubDate>Sun, 02 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jialog.top/posts/os/%E8%99%9A%E6%8B%9F%E5%8C%96--%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86apifork-execve-exit/</guid>
      <description>&lt;h1 id=&#34;操作系统上的进程&#34;&gt;操作系统上的进程&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;背景回顾&lt;/strong&gt;：有关状态机、并发和中断的讨论给我们真正理解操作系统奠定了基础，现在我们正式进入操作系统和应用程序的 “边界” 了。让我们把视角回到单线程应用程序，即 “执行计算指令和系统调用指令的状态机”，开始对操作系统和进程的讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本讲内容&lt;/strong&gt;：操作系统上的进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统上的第一个进程&lt;/li&gt;
&lt;li&gt;UNIX/Linux 进程管理 API: fork, execve, exit&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fork&#34;&gt;fork（）&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;PixPin_2025-02-03_14-37-19.png600&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-03_14-37-19.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;PixPin_2025-02-03_14-51-04.png600&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-03_14-51-04.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解 fork()&lt;/strong&gt;: fork() 会完整复制状态机；新创建的状态机返回值为 0，执行 fork() 的进程会返回子进程的进程号。同时，操作系统中的进程是并行执行的。程序的精确行为并不显然——model checker 可以帮助我们理解它。&lt;/p&gt;
&lt;p&gt;在这个例子中，我们还发现执行 &lt;code&gt;./a.out&lt;/code&gt; 打印的行数和 &lt;code&gt;./a.out | wc -l&lt;/code&gt; 得到的行数不同。根据 “机器永远是对的” 的原则，我们可以通过提出假设 (libc 缓冲区影响) 求证、对比 strace 系统调用序列等方式，最终理解背后的原因。标准输入输出的缓冲控制可以通过 setbuf(3) 和 stdbuf(1) 实现。&lt;/p&gt;
&lt;h2 id=&#34;execve&#34;&gt;execve（）&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;PixPin_2025-02-03_14-54-18.png|525&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-03_14-54-18.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;PixPin_2025-02-03_14-55-00.png|550&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-03_14-55-00.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;exit&#34;&gt;exit（）&lt;/h2&gt;</description>
    </item>
    <item>
      <title>xv6-环境搭建</title>
      <link>https://jialog.top/posts/os/xv6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB/</link>
      <pubDate>Sat, 04 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jialog.top/posts/os/xv6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB/</guid>
      <description>&lt;h2 id=&#34;xv6-启动&#34;&gt;xv6 启动！&lt;/h2&gt;
&lt;p&gt;万事开头难！
&lt;img alt=&#34;PixPin_2024-12-27_21-38-12.png|675&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2024-12-27_21-38-12.png&#34;&gt;
这是我所用的开发环境，Kubuntu+VsCode，这样的环境对我来说是比较舒服的，也是比较好用的在实际使用的过程中我没感觉ubuntu和kubuntu有任何的区别，反正我也不在乎桌面，我只在终端里用。
用debian系的有一个好处就是软件生态真的很不错，可别是最新的，版本什么的直接用apt都能直接获得，虽然不想archwiki那样完善，但是Google一下基本上问题也都能解决。&lt;/p&gt;
&lt;h3 id=&#34;一个很有意思的工具-bear&#34;&gt;一个很有意思的工具 bear&lt;/h3&gt;
&lt;p&gt;我相信有很多同学在用vscode看项目代码的时候会发现，全是红线，项目变得根本就不可读，无法跳转，更无法获得依赖关系，只能把vscode当一个能用鼠标的阉割版的vim用。我们可以获取编译的命令行，然后让vscode知道然后把这些报错给消掉
&lt;strong&gt;1.make -nB&lt;/strong&gt;
当然可以手动获取编译选项，但是这样也是比较复杂的而且十分的低效
&lt;strong&gt;2.bear&lt;/strong&gt;
善于使用工具，君子性非异也，善假于物也。用bear把编译过程包起来就能自动获取编译选项。&lt;/p&gt;
&lt;h3 id=&#34;如何在vscode中debug&#34;&gt;如何在vscode中debug&lt;/h3&gt;
&lt;p&gt;==官方非GUI界面==&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;make&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qemu&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gdb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后系统会在本地启动一个gdb，另起一个终端使用gdb连接。
&lt;img alt=&#34;PixPin_2025-01-04_16-46-16.png600&#34; loading=&#34;lazy&#34; src=&#34;https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-01-04_16-46-16.png&#34;&gt;
到这就说明gdb启动成功了，但是后面会有一个小小的坑。&lt;/p&gt;
&lt;p&gt;Type &amp;ldquo;apropos word&amp;rdquo; to search for commands related to &amp;ldquo;word&amp;rdquo;. warning: File &amp;ldquo;/home/learn_code/xv6-labs-2024/.gdbinit&amp;rdquo; auto-loading has been declined by your `auto-load safe-path&amp;rsquo; set to &amp;ldquo;$debugdir:$datadir/auto-load:/home/learn_code/xv6-riscv/.gdbinit&amp;rdquo;. To enable execution of this file add add-auto-load-safe-path /home/learn_code/xv6-labs-2024/.gdbinit line to your configuration file &amp;ldquo;/root/.config/gdb/gdbinit&amp;rdquo;. To completely disable this security protection add set auto-load safe-path / line to your configuration file &amp;ldquo;/root/.config/gdb/gdbinit&amp;rdquo;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
